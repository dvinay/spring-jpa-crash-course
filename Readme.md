## Spring data jpa ##
- Java provides API for database operation using class-Object concept called Java Persitance API; It is a standard from oracle to perform ORM.
- JPA is part of EJB3 and Java EE.
- JPA comes with specification and API to perform Object and table relation
- ORM is a object relational maping; which is implementation of JPA specification
- example for ORM tools are Hibernate, OpenJPA, EclipseLink etc
- JPA API is set of classes like EntityManager, EntityManagerFactory and provide set of annotations to map java class and instance variable to table in database like @Entity, @Table, @Id, @Column etc
- Without spring data, we need to create a Data Access Object like EmployeeDao interface and it's implementation like EmployeeDaoImpl; which has to use EntityManager (if it's a jpa implementation) or HybernateTemplate (if it's a hybernation vendor) and EntityManagerFactory to perform database opearation. The EntityManagerFactory and EntityManager uses DataSource interface(which uses DriverManagerDataSource) to connect the database.
- Spring data jpa hides the boilerplate code; we no need to write DAO classes or interfaces; We need to define Class same like Table structure and give annotations like @Entity and @Id and create a interface which extends CRUDRepository to provide the basic sql operations as method
- Spring data also provides more functionalities like providing paging and sorting, finder methods etc.

### CRUD Operation ###
- Steps to do crud operations
	- Create Entity or modle(simple POJO) class
	- Create Crud repository interface
	- Configure the Data Source/Data base connection configuration
- Create Entity class similar to table and annotate @Entity, @Table, @Id and @Column
- Create an interface which extends CrudRepository<T, ID extends Serializable>; the crud repository provides basic operations to repository object like create, findOne, findAll, count, save, delete, exist
- add database configuration settings in application.properties file
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/7db210d4ceadfae8da909d48d2d65aea95c15088	)
- Note: spring JPA doesn't show the query while running the code; you can enable to display the query by adding spring.jpa.show-sql=true in application.properties

### ID Generators ###
- When Id as primary key to select the unique row in datbase table; the primary key is depending on the table configuration.
- JPA provides the generation of Id in 4 different ways
	- GenerationType.AUTO
	- GenerationType.IDENTITY
	- GenerationType.SEQUENCE
	- GenerationType.TABLE
- To configure the above id strategy; we need to add the @GeneratedValue(strategy=GenerationType.AUTO) annotation with generation type
- for AUTO; the JPA provider checks the database what kind of strategy does the database supports identity or sequence or table
- for IDENTITY; the primary key is a auto increment; database will automatically increment for us.
- for SEQUENCE; the primary key uses custom logic for sequence to generate
- Note: mysql don't supports sequences
- for TABLE; persistence provider uses a special table to store the keys and uses that keys as primary key for table; we need to create special table along with entity table

- To use IDENTITY; the table must contain primary key as auto increment like
- create table employee( id int PRIMARY KEY AUTO_INCREMENT, name varchar(20))
- the entity must have @GeneratedValue(strategy=GenerationType.IDENTITY)
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/0503d7644c747ee0371bd5e16453cfb9a701af89)

- To use TABLE; we have to create a special table/placeholder for to keep the id
```SQL
-- data table
create table employee(
id int PRIMARY KEY,
name varchar(20)
)
-- special table
create table id_gen(
gen_name varchar(60) PRIMARY KEY,
gen_val int(20)
)
```
- here; gen_val is the value generated by hibernate
- to use table generator we need to give the placeholder table name, primary key and value info as annotation @TableGenerator(name="employee_gen", table="id_gen", pkColumnName="gen_name",valueColumnName="gen_val",allocationSize=100)
- we have to map the table in @GeneratedValue like @GeneratedValue(strategy=GenerationType.TABLE, generator="employee_gen")
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/a8e338bbb0e1f2decc720d668233b10930d896c2)

- Instead of JPA provider Generater strategy, we can develop our own custom strategy; the custom strategy must develop a unique value
	- create a class which implements hibernate IdentifierGenerator
	- overide generate method with custom unique id generation logic
	- to use custom generator using @GenericGenerator and @GeneratedValue 
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/d1f6d473c794a29386b6273e3455e95f59d44892)
```JAVA
@Entity
public class Student {
	@GenericGenerator(name="student_id", strategy="com.fuppino.springdata.idgenerators.custom.CustomRandomIDGenerator")
	@Id
	@GeneratedValue(generator="student_id")
	private Long id;
	private String name;
	... getter and setter
}
```

### Finder methods ###
- Spring JPA provides abstract finder methods to get the data based on columns
- we need to add findBy* methods in repository and use it; 
- List<Product> findByName(String name);
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/eaa17f8452c2d5097ca2e9d1a07511b26d29e4b1)
- for more finder methods [ref](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords) [ref](https://github.com/dvinay/spring-jpa-crash-course/commit/5a081fa512b83730a8721db342234fe7586315b2)

### Paging and Sorting methods ###
- to eanble paging and sorting for your entity; repository interface must extend PagingAndSortingRepository interface
- PagingAndSortingRepository is a child interface of CrudRepository
- To use paging methods, we need to pass Pageable or Sort object while calling the finder methods[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/4ec0ef44da6aac2e722f3fcb3e9d91cc3e09fbf1)
```JAVA
//Pageing
Pageable pageable = new PageRequest(1,2);
Page<Product> products = productRepository.findAll(pageable );
products.forEach(p -> System.out.println(p.getName()));

//Sorting
Iterable<Product> products = productRepository.findAll(new Sort(Direction.DESC,"name"));
products.forEach(p -> System.out.println(p.getName()));
```

### JPQL ###
- Java Persistence Query Language used to perform database table operations against Domain Objects
- By using JPQL we can perform complex query operations. These queries are converting by ORM tools into SQL.
- to run a basic query using jpql, we can use @Query annotation and pass the jpql as parameter
```JAVA
public interface StudentRepository extends CrudRepository<Student, Long>{	
	@Query("from Student")
	List<Student> findAllStudents();
}
``` 
- we get partial data from the table; @Query return as List<Object[]>
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/5f6ae64d287286c00144bd9bbdf1fe10167aa037)
- Note: while using jpql for data change operations like delete, we need to add @Modifying annotation for the function and @Transactional before using the delete function
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/3e61fc4caaa23bddc14ff32c40fbffe16d86c67f)
- by adding Pageable object to function and passing pagerequst;  we can adapt paging and sorting for queries.
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/64f6da9e505a31229bf8951de99a1b683301ba7a)

### Native SQL Queries ###
- Native SQL Queries are used to perform complex query operations and write queries in SQL format.If JPQL queries are difficult to write like joining multiple jobs
- we can write create statements also like Table, db creation
- for Native SQL Queries also, we need to use @Query with nativeQuery boolean parameter as true
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/4df614c25cbec78895e23c764e7884de052206d1)
```JAVA
@Query(nativeQuery=true, value="select * from student")
List<Student> findAllStudentsNQ();
```

### Inheritance Mapping - IS A relationship ###
- If we have some fileds are common in multple tables, we can divide them like Object oriented Parent Child relation ship
- by using Inheritance Mapping, we can apply parent and child relationship from Object Oriented principle to Database; this is called Sub-Type problem in ORM
- e.g: 
	Payment {id, amount} 
		->Card extends Payment {cardnumber}
		->Check extends Payment {checknumber}
- JPA provide three strategies to solve
	- SINGLE_TABLE 
	- TABLE_PER_CLASS
	- JOINED

- SINGLE_TABLE, all the information store in single table; while implmenting this strategy, we need to provide Discrimintor column to differentiate child types
- to implement this strategy, we use @DiscriminatorColumn and @DiscriminatorValue
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/62c445be409b9b6d35c2abdfae860e9ff7ae9aeb)

- TABLE_PER_CLASS, as name suggest it divide each class as a seperate table except the parent class; parent class data fields are duplicate to each child class.
- It increases the duplicate columns into multiple tables; but reduce the read opearation
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/4d54ad237059b14adf4a698fd5b28997d0657076)

- JOINED, uses each class as a seperate table with foreign key as ref between tables.
- Joined is best approach; it follows the database normalization and less data with proper reference key
- To refer the primary key and foreignkey relation ship; we need to use @PrimaryKeyJoinColumn(name="parentclass_id") annotation
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/0e987681888c8727ba8087a7fef610b206b7b2ee)
- after runnning this child class insertion; it will create a column in parent table and ref to child table

### Component Mapping - Has A relationship ###
- It's process to store the has-a relationship data into one table; need to use @Embedded and @Embeddable annotations [ref](https://github.com/dvinay/spring-jpa-crash-course/commit/231c30312c5f5702245a231bf3635b10dfd6361f) 

### Association Mapping ###
- While normalizing the database tables, we will store data into multiple tables
- JPA has provided 4 annotations to configure the association mapping @OneToOne, @OneToMany, @ManyToOne and @ManyToMany
- e.g for one to many, to fetch data in bi-directional we need to map annotaion to both parent class and child class

#### OneToMany and ManyToOne ####
- client 1 -> * PhoneNumber
	- Client

		@OneToMany(mappedBy="customer",cascade=CascadeType.ALL)

		List<PhoneNumber> phoneNumbers;


	- PhoneNumber

		@ManyToOne
		
		@JoinColumn(name="fk_keycolumnname")
		
		Client client;

- [database ref](https://github.com/dvinay/spring-jpa-crash-course/blob/master/associations/src/main/resources/onetomany.txt)
- [parent entity](https://github.com/dvinay/spring-jpa-crash-course/blob/master/associations/src/main/java/com/fuppino/spring/associations/entities/Customer.java)
- [child entity](https://github.com/dvinay/spring-jpa-crash-course/blob/master/associations/src/main/java/com/fuppino/spring/associations/entities/PhoneNumber.java)

- Cascading is process of propagating the operations between associated tables
- we can controll the cascade propagation by giving different values to cascade parameter in the association annotation
	- persist - insert on main object should propagate to child object
	- merge   - insert and update on main object should propagate to child object
	- remove  - delete on main object should propagate to child object
	- refresh - refreshing on main object should propagate to child object
	- detach  - detach on main object should propagate to child object
	- all  	  - all operations on main object should propagate to child object
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/c9451941ab0e2e6562dd9cb70651c8923f896975)

- To read the association data
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/7bf5b3b85a7273bc5cfc5c6a77d95c60123b7831)
- To update operation, if the customer has cascade option with all or merge then it will update both customer and phonenumber.
- while doing update operation, hibernate check the dirty flag; means if the child doen't require to update new data. it will skip the update statement
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/4e94cd20e420c47b9eacfe20a3c3d235d4c140ba)
- Lazy loaing vs Eager loading
	- while fetching the association data, hibernate look the data loading type; default is lazy loading.
	- Eager loading - while fetching the parent data the child data also load
	- Lazy loading - while fetching the parent data the child data don't load; but while using the child data like getNumber() the data load. it's a on-demand data loading
	- Lazy loading improve the performance; because it fetched on-demand/whie first time usage of the child data
	- To work lazy loading add @Transactional from org.springframework.transaction.annotation package
	- for eager loading, jpa query will be the join query
	- for lazy loading, jpa run two diffirent queries for to fetch parent data and fetch child data
- e.g: 	
```JAVA
@OneToMany(mappedBy="customer",cascade=CascadeType.ALL,fetch=FetchType.EAGER)
private Set<PhoneNumber> numbers;
```
- while doing delete operation; jpa delete the child data first and then parent data to avoid fk conflict
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/48bddfd1ccd01bea0888def6133a15e63a4d4912)

#### ManyToMany ####
- Programmer * <-> * Project
- in Many to many association we need a extra table to store the mapping information
	- Programmer

		@ManyToMany(cascade=CascadeType.ALL)

		@JoinTable(name="programmers_projects",
			joinColumns=@JoinColumn(name="programmer_id",referencedColumnName="id"),
			inverseJoinColumns=@JoinColumn(name="project_id",referencedColumnName="id"))

		private Set<Project> projects;


	- Project

		@ManyToMany(mappedBy="projects")

		private Set<Programmer> Programmer;
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/69851606d51cb0b81acefa111595de178deff638)

- [database ref](https://github.com/dvinay/spring-jpa-crash-course/blob/master/manytomanyassociation/src/main/resources/manytomany.txt)
- [Programmer entity](https://github.com/dvinay/spring-jpa-crash-course/blob/master/manytomanyassociation/src/main/java/com/fuppino/spring/associations/entities/Programmer.java)
- [Project entity](https://github.com/dvinay/spring-jpa-crash-course/blob/master/manytomanyassociation/src/main/java/com/fuppino/spring/associations/entities/Project.java)
- While performing read operation it loads the data as lazy loading; to fetch the complte data we need to add @Transactional
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/30fdf7341675a1b7a6a7cf86b5d524b9f6377514)

#### OneToOne ####
- Person 1 <-> 1 License
- in one to one association has two ways, 1) sharing the PK, 2) one table PK is a FK for other table
	- Person

		@OneToOne(mappedBy = "person")

		private License license;

	- License

		@OneToOne(cascade = CascadeType.ALL)

		@JoinColumn(name = "person_id")

		private Person person;

### Caching ###
- Caching is process of storing the database data into disk or file to get the data next time without hitting the database again and agian
- Hibernate supports two levels of caching
	- Level 1 -> Session 
	- Level 2 -> SessionFactory
- Level-1 is default enable always
- Level-2 cache objects will be shared across all the sessions(all uses)
- Hibernate doesn't have in-built support for Level-2; we need to use other supports to get Level-2 cache
	- e.g: EhCache, swaram Cache, Jboss Tree cache, OS Cache, Tangosol Cache

#### L1 - Caching ####
- L1 cache is always enabled at persistance context; to enable in the code level we need to add @Transactional from spring annotation package to our test method or service method to fetch
- Transactional annotation enables the L1 cache; when first time it hit the database and fetch the record it keep in session; for next two time fetch it will get data from the L1 cache
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/2268fd439b87eb6af4bc1f544d1ce440726c8122)
```JAVA
@Test
@Transactional
public void testCaching() {
	productRepository.findOne(2);
	productRepository.findOne(2);
	productRepository.findOne(2);
}
```
- To remove object from Level-1 we can evict the object from the persistance context
- To access the low level components like entity manager and hibernate session; we need to use entitymanager.unwrap() to access the session.
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/2f20b921828963ccc1caf14625160a6e2aacfc41)
```JAVA
@Transactional
public void testCaching() {
	Session session = entityManager.unwrap(Session.class);
	Product product = productRepository.findOne(2);
	
	productRepository.findOne(2);
	
	session.evict(product);
	
	productRepository.findOne(2);
}
```

#### L2 - Caching ####
- Eh Cache, is a caching framework; fast and lightweight [ref](http://www.ehcache.org/documentation/2.8/configuration/configuration.html)
- It supports in-memory and disk based
- we can provide timeout and life time of objects
- Steps to add L2 cache using EhCache
	- add the EhCache dependecy
```XML
<dependency>
	<groupId>org.hibernate</groupId>
	<artifactId>hibernate-ehcache</artifactId>
</dependency>
```
	- Enable the EhCache in application.properties
```JAVA
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
spring.jpa.properties.javax.persistence.sharedCache.mode=ALL
spring.cache.ehcache.config=classpath:ehcahe.xml
```
	- Configure the ehcache.xml file to provide storage and time information
```XML
<ehcache>
	<diskpath path="java.io.tmpdir"/>
	
	<defaultCache 
		maxElementsInMemeory="100" 
		eternal="false" 
		timeToIdleSeconds="5"
     	timeToLiveSeconds="10"
     	overflowToDisk="true"/>
</ehcache>
```
	- Make entities cacheable/add annotations
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/725a1774b8508231c053cd85214a29a070187ebe)

#### Cache Concurrency Strategy ####
- READ_ONLY
	- used for only when entities never change, only for read only purpose applications
- NONSTRICT_READ_WRITE
	- cache will update only the transaction commits to the database; mean time if another transaction read the data it will get wrong data.
- READ_WRITE
	- soft locks will be used; more consistance
- TRANSACTIONAL
	- XA/Distributed transactions; if any changes in cache will be commit to across the database

### Transaction Management ###
- The process of excuting bunch of operation by appling do all or nothing principle is called Transaction
- It's atomic unit of work
- Transaction has four key properties called ACID
	- Automicity - Transaction sould work as single unit of work
	- Consistency - db should be left end of the transaction
	- Isolation - each transaction has to work has individually; without depending on other transaction
	- Durability - changes should commited to database

- Components in Transaction management; 
	- Transactional Application - our application which do transactions
	- Transactional Manager/Transaction Co-ordinates - which use Resource Manager to do transactions
	- Resource Manager - which know how to use DB api's like jdbc,jpa etc

- Note: if transaction happen in one db, it's called local Transaction. If it's a multiple databases, it's called distributed Transaction
- to make sure one operation as transaction we need to add @Transactional to make sure the all the db operations follow ACID property
[ref](https://github.com/dvinay/spring-jpa-crash-course/commit/1947fd31e03ff3975bf98a9705d502f6d2bfef5a)




















